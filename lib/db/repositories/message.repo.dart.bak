import 'package:amigo/models/message_model.dart';
import 'package:drift/drift.dart';
import '../sqlite.db.dart';
import '../sqlite.schema.dart';

class MessageRepository {
  final sqliteDatabase = SqliteDatabase.instance;

  /// Helper method to convert Message row to MessageModel
  /// Joins with Users table to get senderName and senderProfilePic
  Future<MessageModel> _messageToModel(Message message) async {
    final db = sqliteDatabase.database;

    // Get sender info from Users table
    String senderName = 'Unknown';
    String? senderProfilePic;
    final sender = await (db.select(db.users)
          ..where((t) => t.id.equals(message.senderId)))
        .getSingleOrNull();

    if (sender != null) {
      senderName = sender.name;
      senderProfilePic = sender.profilePic;
    }

    // Get reply to message if exists
    MessageModel? replyToMessage;
    int? replyToMessageId;
    if (message.metadata != null && message.metadata!['reply_to'] != null) {
      final replyToData = message.metadata!['reply_to'] as Map<String, dynamic>;
      replyToMessageId = replyToData['message_id'] as int?;
      if (replyToMessageId != null) {
        final replyMsg = await getMessageById(replyToMessageId);
        if (replyMsg != null) {
          replyToMessage = replyMsg;
        }
      }
    }

    return MessageModel(
      id: message.id.toInt(),
      body: message.body ?? '',
      type: message.type,
      senderId: message.senderId,
      conversationId: message.conversationId,
      createdAt: message.sentAt,
      editedAt: message.metadata?['edited_at']?.toString(),
      metadata: message.metadata,
      attachments: message.attachments,
      deleted: message.isDeleted,
      senderName: senderName,
      senderProfilePic: senderProfilePic,
      replyToMessage: replyToMessage,
      replyToMessageId: replyToMessageId,
      isDelivered: message.status == 'delivered' || message.status == 'read',
    );
  }

  /// Insert a single message
  Future<void> insertMessage(MessageModel message) async {
    final db = sqliteDatabase.database;

    final messageCompanion = MessagesCompanion.insert(
      id: Value(BigInt.from(message.id)),
      conversationId: message.conversationId,
      senderId: message.senderId,
      type: message.type,
      body: Value(message.body.isEmpty ? null : message.body),
      status: message.isDelivered ? 'delivered' : 'sent',
      attachments: Value(message.attachments),
      metadata: Value(message.metadata),
      isPinned: const Value(false),
      isStarred: const Value(false),
      isReplied: Value(message.replyToMessageId != null),
      isForwarded: const Value(false),
      sentAt: message.createdAt,
      isDeleted: Value(message.deleted),
    );

    await db.into(db.messages).insertOnConflictUpdate(messageCompanion);
  }

  /// Insert multiple messages (bulk insert)
  Future<void> insertMessages(List<MessageModel> messages) async {
    final db = sqliteDatabase.database;

    for (final message in messages) {
      final messageCompanion = MessagesCompanion.insert(
        id: Value(BigInt.from(message.id)),
        conversationId: message.conversationId,
        senderId: message.senderId,
        type: message.type,
        body: Value(message.body.isEmpty ? null : message.body),
        status: message.isDelivered ? 'delivered' : 'sent',
        attachments: Value(message.attachments),
        metadata: Value(message.metadata),
        isPinned: const Value(false),
        isStarred: const Value(false),
        isReplied: Value(message.replyToMessageId != null),
        isForwarded: const Value(false),
        sentAt: message.createdAt,
        isDeleted: Value(message.deleted),
      );
      await db.into(db.messages).insertOnConflictUpdate(messageCompanion);
    }
  }

  /// Get a message by ID
  Future<MessageModel?> getMessageById(int messageId) async {
    final db = sqliteDatabase.database;

    final message = await (db.select(db.messages)
          ..where((t) => t.id.equals(BigInt.from(messageId))))
        .getSingleOrNull();

    if (message == null) return null;

    return await _messageToModel(message);
  }

  /// Get all messages for a conversation
  Future<List<MessageModel>> getMessagesByConversation(
    int conversationId, {
    int? limit,
    int offset = 0,
    bool includeDeleted = false,
  }) async {
    final db = sqliteDatabase.database;

    final query = db.select(db.messages)
      ..where((t) =>
          t.conversationId.equals(conversationId) &
          (includeDeleted ? const Constant(true) : t.isDeleted.equals(false)))
      ..orderBy([
        (t) => OrderingTerm(expression: t.sentAt, mode: OrderingMode.desc),
      ]);

    if (limit != null) {
      query.limit(limit, offset: offset);
    }

    final messages = await query.get();

    final result = <MessageModel>[];
    for (final message in messages) {
      result.add(await _messageToModel(message));
    }

    return result;
  }

  /// Get messages by conversation with pagination
  Future<List<MessageModel>> getMessagesByConversationPaginated(
    int conversationId, {
    required int limit,
    int offset = 0,
    bool includeDeleted = false,
  }) async {
    return getMessagesByConversation(
      conversationId,
      limit: limit,
      offset: offset,
      includeDeleted: includeDeleted,
    );
  }

  /// Get messages by sender
  Future<List<MessageModel>> getMessagesBySender(int senderId) async {
    final db = sqliteDatabase.database;

    final query = db.select(db.messages)
      ..where((t) => t.senderId.equals(senderId) & t.isDeleted.equals(false))
      ..orderBy([
        (t) => OrderingTerm(expression: t.sentAt, mode: OrderingMode.desc),
      ]);

    final messages = await query.get();

    final result = <MessageModel>[];
    for (final message in messages) {
      result.add(await _messageToModel(message));
    }

    return result;
  }

  /// Get messages by type
  Future<List<MessageModel>> getMessagesByType(String type) async {
    final db = sqliteDatabase.database;

    final query = db.select(db.messages)
      ..where((t) => t.type.equals(type) & t.isDeleted.equals(false))
      ..orderBy([
        (t) => OrderingTerm(expression: t.sentAt, mode: OrderingMode.desc),
      ]);

    final messages = await query.get();

    final result = <MessageModel>[];
    for (final message in messages) {
      result.add(await _messageToModel(message));
    }

    return result;
  }

  /// Get messages by conversation and type
  Future<List<MessageModel>> getMessagesByConversationAndType(
    int conversationId,
    String type,
  ) async {
    final db = sqliteDatabase.database;

    final query = db.select(db.messages)
      ..where((t) =>
          t.conversationId.equals(conversationId) &
          t.type.equals(type) &
          t.isDeleted.equals(false))
      ..orderBy([
        (t) => OrderingTerm(expression: t.sentAt, mode: OrderingMode.desc),
      ]);

    final messages = await query.get();

    final result = <MessageModel>[];
    for (final message in messages) {
      result.add(await _messageToModel(message));
    }

    return result;
  }

  /// Search messages by body content
  Future<List<MessageModel>> searchMessages(String searchQuery) async {
    final db = sqliteDatabase.database;

    final query = db.select(db.messages)
      ..where((t) =>
          t.body.like('%$searchQuery%') & t.isDeleted.equals(false))
      ..orderBy([
        (t) => OrderingTerm(expression: t.sentAt, mode: OrderingMode.desc),
      ]);

    final messages = await query.get();

    final result = <MessageModel>[];
    for (final message in messages) {
      result.add(await _messageToModel(message));
    }

    return result;
  }

  /// Search messages in a specific conversation
  Future<List<MessageModel>> searchMessagesInConversation(
    int conversationId,
    String searchQuery,
  ) async {
    final db = sqliteDatabase.database;

    final query = db.select(db.messages)
      ..where((t) =>
          t.conversationId.equals(conversationId) &
          t.body.like('%$searchQuery%') &
          t.isDeleted.equals(false))
      ..orderBy([
        (t) => OrderingTerm(expression: t.sentAt, mode: OrderingMode.desc),
      ]);

    final messages = await query.get();

    final result = <MessageModel>[];
    for (final message in messages) {
      result.add(await _messageToModel(message));
    }

    return result;
  }

  /// Get pinned messages for a conversation
  Future<List<MessageModel>> getPinnedMessages(int conversationId) async {
    final db = sqliteDatabase.database;

    final query = db.select(db.messages)
      ..where((t) =>
          t.conversationId.equals(conversationId) &
          t.isPinned.equals(true) &
          t.isDeleted.equals(false))
      ..orderBy([
        (t) => OrderingTerm(expression: t.sentAt, mode: OrderingMode.desc),
      ]);

    final messages = await query.get();

    final result = <MessageModel>[];
    for (final message in messages) {
      result.add(await _messageToModel(message));
    }

    return result;
  }

  /// Get starred messages for a conversation
  Future<List<MessageModel>> getStarredMessages(int conversationId) async {
    final db = sqliteDatabase.database;

    final query = db.select(db.messages)
      ..where((t) =>
          t.conversationId.equals(conversationId) &
          t.isStarred.equals(true) &
          t.isDeleted.equals(false))
      ..orderBy([
        (t) => OrderingTerm(expression: t.sentAt, mode: OrderingMode.desc),
      ]);

    final messages = await query.get();

    final result = <MessageModel>[];
    for (final message in messages) {
      result.add(await _messageToModel(message));
    }

    return result;
  }

  /// Get last message for a conversation
  Future<MessageModel?> getLastMessage(int conversationId) async {
    final db = sqliteDatabase.database;

    final query = db.select(db.messages)
      ..where((t) =>
          t.conversationId.equals(conversationId) & t.isDeleted.equals(false))
      ..orderBy([
        (t) => OrderingTerm(expression: t.sentAt, mode: OrderingMode.desc),
      ])
      ..limit(1);

    final message = await query.getSingleOrNull();

    if (message == null) return null;

    return await _messageToModel(message);
  }

  /// Update a message
  Future<void> updateMessage(MessageModel message) async {
    final db = sqliteDatabase.database;

    final companion = MessagesCompanion(
      id: Value(BigInt.from(message.id)),
      conversationId: Value(message.conversationId),
      senderId: Value(message.senderId),
      type: Value(message.type),
      body: Value(message.body.isEmpty ? null : message.body),
      status: Value(message.isDelivered ? 'delivered' : 'sent'),
      attachments: Value(message.attachments),
      metadata: Value(message.metadata),
      isDeleted: Value(message.deleted),
    );

    await db.update(db.messages).replace(companion);
  }

  /// Update message status
  Future<void> updateMessageStatus(int messageId, String status) async {
    final db = sqliteDatabase.database;
    await (db.update(db.messages)
          ..where((t) => t.id.equals(BigInt.from(messageId))))
        .write(MessagesCompanion(status: Value(status)));
  }

  /// Mark message as deleted (soft delete)
  Future<void> markAsDeleted(int messageId, bool isDeleted) async {
    final db = sqliteDatabase.database;
    await (db.update(db.messages)
          ..where((t) => t.id.equals(BigInt.from(messageId))))
        .write(MessagesCompanion(isDeleted: Value(isDeleted)));
  }

  /// Toggle pin status of a message
  Future<void> togglePin(int messageId, bool isPinned) async {
    final db = sqliteDatabase.database;
    await (db.update(db.messages)
          ..where((t) => t.id.equals(BigInt.from(messageId))))
        .write(MessagesCompanion(isPinned: Value(isPinned)));
  }

  /// Toggle star status of a message
  Future<void> toggleStar(int messageId, bool isStarred) async {
    final db = sqliteDatabase.database;
    await (db.update(db.messages)
          ..where((t) => t.id.equals(BigInt.from(messageId))))
        .write(MessagesCompanion(isStarred: Value(isStarred)));
  }

  /// Delete a message by ID (hard delete)
  Future<bool> deleteMessage(int messageId) async {
    final db = sqliteDatabase.database;
    final deleted = await (db.delete(db.messages)
          ..where((t) => t.id.equals(BigInt.from(messageId))))
        .go();
    return deleted > 0;
  }

  /// Delete multiple messages by their IDs
  Future<int> deleteMessages(List<int> messageIds) async {
    if (messageIds.isEmpty) return 0;

    final db = sqliteDatabase.database;
    final deleted = await (db.delete(db.messages)
          ..where((t) =>
              t.id.isIn(messageIds.map((id) => BigInt.from(id)).toList())))
        .go();
    return deleted;
  }

  /// Delete all messages for a conversation
  Future<int> deleteMessagesByConversation(int conversationId) async {
    final db = sqliteDatabase.database;
    final deleted = await (db.delete(db.messages)
          ..where((t) => t.conversationId.equals(conversationId)))
        .go();
    return deleted;
  }

  /// Clear all messages from the database
  Future<void> clearAllMessages() async {
    final db = sqliteDatabase.database;
    await db.delete(db.messages).go();
  }

  /// Get message count for a conversation
  Future<int> getMessageCount(int conversationId) async {
    final db = sqliteDatabase.database;
    final messages = await (db.select(db.messages)
          ..where((t) =>
              t.conversationId.equals(conversationId) &
              t.isDeleted.equals(false)))
        .get();
    return messages.length;
  }

  /// Get unread message count for a conversation
  Future<int> getUnreadMessageCount(
    int conversationId,
    int lastReadMessageId,
  ) async {
    final db = sqliteDatabase.database;
    final messages = await (db.select(db.messages)
          ..where((t) =>
              t.conversationId.equals(conversationId) &
              t.id.isBiggerThanValue(BigInt.from(lastReadMessageId)) &
              t.isDeleted.equals(false)))
        .get();
    return messages.length;
  }

  /// Get messages after a specific message ID (for pagination)
  Future<List<MessageModel>> getMessagesAfter(
    int conversationId,
    int afterMessageId, {
    int limit = 50,
  }) async {
    final db = sqliteDatabase.database;

    final query = db.select(db.messages)
      ..where((t) =>
          t.conversationId.equals(conversationId) &
          t.id.isSmallerThanValue(BigInt.from(afterMessageId)) &
          t.isDeleted.equals(false))
      ..orderBy([
        (t) => OrderingTerm(expression: t.sentAt, mode: OrderingMode.desc),
      ])
      ..limit(limit);

    final messages = await query.get();

    final result = <MessageModel>[];
    for (final message in messages) {
      result.add(await _messageToModel(message));
    }

    return result;
  }

  /// Get messages before a specific message ID (for pagination)
  Future<List<MessageModel>> getMessagesBefore(
    int conversationId,
    int beforeMessageId, {
    int limit = 50,
  }) async {
    final db = sqliteDatabase.database;

    final query = db.select(db.messages)
      ..where((t) =>
          t.conversationId.equals(conversationId) &
          t.id.isBiggerThanValue(BigInt.from(beforeMessageId)) &
          t.isDeleted.equals(false))
      ..orderBy([
        (t) => OrderingTerm(expression: t.sentAt, mode: OrderingMode.asc),
      ])
      ..limit(limit);

    final messages = await query.get();

    final result = <MessageModel>[];
    for (final message in messages) {
      result.add(await _messageToModel(message));
    }

    return result;
  }

  /// Check if a message exists by ID
  Future<bool> messageExists(int messageId) async {
    final db = sqliteDatabase.database;
    final message = await (db.select(db.messages)
          ..where((t) => t.id.equals(BigInt.from(messageId))))
        .getSingleOrNull();
    return message != null;
  }

  /// Get total message count
  Future<int> getTotalMessageCount() async {
    final db = sqliteDatabase.database;
    final messages = await db.select(db.messages).get();
    return messages.length;
  }
}

