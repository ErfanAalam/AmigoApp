import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/group_model.dart';
import '../models/community_model.dart';
import '../api/user.service.dart';
import '../db/repositories/groups_repository.dart';
import '../db/repositories/communities_repository.dart';
import '../services/socket/websocket_message_handler.dart';
import '../services/last_message_storage_service.dart';
import '../api/chats.services.dart';

/// State class for group list
class GroupListState {
  final List<GroupModel> groups;
  final List<CommunityModel> communities;
  final bool isLoading;
  final int? activeConversationId;
  final Map<int, bool> typingUsers; // conversationId -> isTyping
  final Map<int, Set<String>>
  typingUserNames; // conversationId -> Set of userNames
  final String searchQuery;

  GroupListState({
    this.groups = const [],
    this.communities = const [],
    this.isLoading = false,
    this.activeConversationId,
    Map<int, bool>? typingUsers,
    Map<int, Set<String>>? typingUserNames,
    this.searchQuery = '',
  }) : typingUsers = typingUsers ?? {},
       typingUserNames = typingUserNames ?? {};

  GroupListState copyWith({
    List<GroupModel>? groups,
    List<CommunityModel>? communities,
    bool? isLoading,
    int? activeConversationId,
    Map<int, bool>? typingUsers,
    Map<int, Set<String>>? typingUserNames,
    String? searchQuery,
    bool clearActiveConversation = false,
    bool clearTypingUsers = false,
  }) {
    return GroupListState(
      groups: groups ?? this.groups,
      communities: communities ?? this.communities,
      isLoading: isLoading ?? this.isLoading,
      activeConversationId: clearActiveConversation
          ? null
          : (activeConversationId ?? this.activeConversationId),
      typingUsers: clearTypingUsers ? {} : (typingUsers ?? this.typingUsers),
      typingUserNames: typingUserNames ?? this.typingUserNames,
      searchQuery: searchQuery ?? this.searchQuery,
    );
  }

  /// Get filtered items (groups + communities) based on search query
  List<dynamic> get filteredItems {
    if (searchQuery.isEmpty) {
      return [...groups, ...communities];
    }
    final query = searchQuery.toLowerCase();
    final filteredGroups = groups.where((group) {
      return group.title.toLowerCase().contains(query) ||
          group.members.any(
            (member) => member.name.toLowerCase().contains(query),
          );
    }).toList();

    final filteredCommunities = communities.where((community) {
      return community.name.toLowerCase().contains(query);
    }).toList();

    return [...filteredGroups, ...filteredCommunities];
  }
}

/// Provider for group list state
final groupListProvider = NotifierProvider<GroupListNotifier, GroupListState>(
  () => GroupListNotifier(),
);

class GroupListNotifier extends Notifier<GroupListState> {
  final UserService _userService = UserService();
  final GroupsRepository _groupsRepo = GroupsRepository();
  final CommunitiesRepository _communitiesRepo = CommunitiesRepository();
  final WebSocketMessageHandler _messageHandler = WebSocketMessageHandler();
  final LastMessageStorageService _lastMessageStorage =
      LastMessageStorageService.instance;
  final ChatsServices _chatsServices = ChatsServices();

  StreamSubscription<Map<String, dynamic>>? _typingSubscription;
  StreamSubscription<Map<String, dynamic>>? _messageSubscription;
  StreamSubscription<Map<String, dynamic>>? _mediaSubscription;
  StreamSubscription<Map<String, dynamic>>? _conversationAddedSubscription;
  StreamSubscription<Map<String, dynamic>>? _messageDeleteSubscription;

  final Map<int, Timer?> _typingTimers = {};

  @override
  GroupListState build() {
    // Initialize and load data
    Future.microtask(() async {
      await _loadFromLocal();
      await loadGroupsAndCommunities();
      _setupWebSocketListeners();
    });
    return GroupListState();
  }

  /// Load groups and communities from local DB first
  Future<void> _loadFromLocal() async {
    try {
      final localGroups = await _groupsRepo.getAllGroups();
      final localCommunities = await _communitiesRepo.getAllCommunities();

      if (localGroups.isNotEmpty || localCommunities.isNotEmpty) {
        final updatedGroups = await _updateGroupsWithStoredLastMessages(
          localGroups,
        );

        // Sort groups by last message time
        updatedGroups.sort((a, b) {
          final aTime = a.lastMessageAt ?? a.joinedAt;
          final bTime = b.lastMessageAt ?? b.joinedAt;
          return DateTime.parse(bTime).compareTo(DateTime.parse(aTime));
        });

        state = state.copyWith(
          groups: updatedGroups,
          communities: localCommunities,
          isLoading: false,
        );
      }
    } catch (e) {
      debugPrint('❌ Error loading from local DB: $e');
    }
  }

  /// Update groups with stored last messages
  Future<List<GroupModel>> _updateGroupsWithStoredLastMessages(
    List<GroupModel> groups,
  ) async {
    try {
      final storedLastMessages = await _lastMessageStorage
          .getAllGroupLastMessages();
      final updatedGroups = <GroupModel>[];

      for (final group in groups) {
        final storedMessage = storedLastMessages[group.conversationId];

        if (storedMessage != null) {
          final lastMessage = GroupLastMessage(
            id: storedMessage['id'] ?? 0,
            body: storedMessage['body'] ?? '',
            type: storedMessage['type'] ?? 'text',
            senderId: storedMessage['sender_id'] ?? 0,
            senderName: storedMessage['sender_name'] ?? '',
            createdAt:
                storedMessage['created_at'] ?? DateTime.now().toIso8601String(),
            conversationId: group.conversationId,
          );

          final updatedMetadata = GroupMetadata(
            lastMessage: lastMessage,
            totalMessages: group.metadata?.totalMessages ?? 0,
            createdAt: group.metadata?.createdAt,
            createdBy: group.metadata?.createdBy ?? 0,
          );

          final updatedGroup = GroupModel(
            conversationId: group.conversationId,
            title: group.title,
            type: group.type,
            members: group.members,
            metadata: updatedMetadata,
            lastMessageAt: lastMessage.createdAt,
            role: group.role,
            unreadCount: group.unreadCount,
            joinedAt: group.joinedAt,
          );

          updatedGroups.add(updatedGroup);
        } else {
          updatedGroups.add(group);
        }
      }

      return updatedGroups;
    } catch (e) {
      debugPrint('❌ Error updating groups with stored last messages: $e');
      return groups;
    }
  }

  /// Load groups and communities from server
  Future<void> loadGroupsAndCommunities({bool silent = false}) async {
    if (!silent) {
      state = state.copyWith(isLoading: true);
    }

    try {
      // Load groups
      final groupResponse = await _userService.getChatList('group');
      // Load communities
      final communityResponse = await _userService.getCommunityChatList();

      List<GroupModel> groups = [];
      List<CommunityModel> communities = [];
      bool hasServerData = false;

      // Process groups
      if (groupResponse['success']) {
        final dynamic responseData = groupResponse['data'];
        List<dynamic> conversationsList = [];

        if (responseData is List) {
          conversationsList = responseData;
        } else if (responseData is Map<String, dynamic>) {
          if (responseData.containsKey('data') &&
              responseData['data'] is List) {
            conversationsList = responseData['data'] as List<dynamic>;
          } else {
            for (var key in responseData.keys) {
              if (responseData[key] is List) {
                conversationsList = responseData[key] as List<dynamic>;
                break;
              }
            }
          }
        }

        groups = conversationsList
            .where((json) => json['type'] == 'group')
            .map((json) => _convertToGroupModel(json))
            .toList();

        if (groups.isNotEmpty) {
          hasServerData = true;

          // Store last messages
          for (final group in groups) {
            if (group.metadata?.lastMessage != null) {
              final lastMsg = group.metadata!.lastMessage!;
              await _lastMessageStorage
                  .storeGroupLastMessage(group.conversationId, {
                    'id': lastMsg.id,
                    'body': lastMsg.body,
                    'type': lastMsg.type,
                    'sender_id': lastMsg.senderId,
                    'sender_name': lastMsg.senderName,
                    'created_at': lastMsg.createdAt,
                    'conversation_id': group.conversationId,
                  });
            }
          }

          await _groupsRepo.insertOrUpdateGroups(groups);
        }
      }

      // Process communities
      if (communityResponse['success'] && communityResponse['data'] != null) {
        final List<dynamic> communityList =
            communityResponse['data'] as List<dynamic>;
        communities = communityList
            .map(
              (json) => CommunityModel.fromJson(json as Map<String, dynamic>),
            )
            .toList();

        if (communities.isNotEmpty) {
          hasServerData = true;
          await _communitiesRepo.insertOrUpdateCommunities(communities);
        }
      }

      // If server returned empty but we have local data, use local data
      if (!hasServerData) {
        final localGroups = await _groupsRepo.getAllGroups();
        final localCommunities = await _communitiesRepo.getAllCommunities();
        groups = localGroups;
        communities = localCommunities;
      }

      // Use server data if available, otherwise use local data
      final finalGroups = groups.isNotEmpty ? groups : <GroupModel>[];
      final updatedGroups = finalGroups.isNotEmpty
          ? finalGroups
          : await _updateGroupsWithStoredLastMessages(
              await _groupsRepo.getAllGroups(),
            );

      // Sort groups by last message time
      updatedGroups.sort((a, b) {
        final aTime = a.lastMessageAt ?? a.joinedAt;
        final bTime = b.lastMessageAt ?? b.joinedAt;
        return DateTime.parse(bTime).compareTo(DateTime.parse(aTime));
      });

      state = state.copyWith(
        groups: updatedGroups,
        communities: communities.isNotEmpty
            ? communities
            : await _communitiesRepo.getAllCommunities(),
        isLoading: false,
      );
    } catch (e) {
      debugPrint('❌ Error loading groups and communities: $e');
      try {
        final localGroups = await _groupsRepo.getAllGroups();
        final localCommunities = await _communitiesRepo.getAllCommunities();
        final updatedGroups = await _updateGroupsWithStoredLastMessages(
          localGroups,
        );

        updatedGroups.sort((a, b) {
          final aTime = a.lastMessageAt ?? a.joinedAt;
          final bTime = b.lastMessageAt ?? b.joinedAt;
          return DateTime.parse(bTime).compareTo(DateTime.parse(aTime));
        });

        state = state.copyWith(
          groups: updatedGroups,
          communities: localCommunities,
          isLoading: false,
        );
      } catch (localError) {
        debugPrint('❌ Error loading from local DB: $localError');
        state = state.copyWith(groups: [], communities: [], isLoading: false);
      }
    }
  }

  /// Convert JSON to GroupModel
  GroupModel _convertToGroupModel(Map<String, dynamic> json) {
    return GroupModel(
      conversationId: json['conversationId'] ?? 0,
      title: json['title'] ?? 'Unnamed Group',
      type: json['type'] ?? 'group',
      members: _parseMembers(json['members']),
      metadata: json['metadata'] != null
          ? GroupMetadata.fromJson(json['metadata'])
          : null,
      lastMessageAt: json['lastMessageAt'],
      role: json['role'],
      unreadCount: json['unreadCount'] ?? 0,
      joinedAt: json['joinedAt'] ?? DateTime.now().toIso8601String(),
    );
  }

  /// Parse members from JSON
  List<GroupMember> _parseMembers(dynamic membersData) {
    if (membersData == null) return [];

    if (membersData is List) {
      return membersData.map((member) => GroupMember.fromJson(member)).toList();
    }

    return [];
  }

  /// Set active conversation
  void setActiveConversation(int? conversationId) {
    state = state.copyWith(activeConversationId: conversationId);
    if (conversationId != null) {
      clearUnreadCount(conversationId);
    }
  }

  /// Clear unread count for a group
  void clearUnreadCount(int conversationId) {
    final groupIndex = state.groups.indexWhere(
      (group) => group.conversationId == conversationId,
    );

    if (groupIndex != -1) {
      final group = state.groups[groupIndex];
      if (group.unreadCount > 0) {
        final updatedGroup = GroupModel(
          conversationId: group.conversationId,
          title: group.title,
          type: group.type,
          members: group.members,
          metadata: group.metadata,
          lastMessageAt: group.lastMessageAt,
          role: group.role,
          unreadCount: 0,
          joinedAt: group.joinedAt,
        );

        final updatedGroups = List<GroupModel>.from(state.groups);
        updatedGroups[groupIndex] = updatedGroup;

        state = state.copyWith(groups: updatedGroups);
        _groupsRepo.insertOrUpdateGroup(updatedGroup);
      }
    }
  }

  /// Update search query
  void updateSearchQuery(String query) {
    state = state.copyWith(searchQuery: query.trim());
  }

  /// Set up WebSocket listeners
  void _setupWebSocketListeners() {
    _typingSubscription = _messageHandler.typingStream.listen(
      _handleTypingMessage,
      onError: (error) {
        debugPrint('❌ Typing stream error: $error');
      },
    );

    _messageSubscription = _messageHandler.messageStream.listen(
      _handleNewGroupMessage,
      onError: (error) {
        debugPrint('❌ Message stream error: $error');
      },
    );

    _mediaSubscription = _messageHandler.mediaStream.listen(
      _handleNewGroupMessage,
      onError: (error) {
        debugPrint('❌ Media stream error: $error');
      },
    );

    _conversationAddedSubscription = _messageHandler.conversationAddedStream
        .listen(
          _handleConversationAdded,
          onError: (error) {
            debugPrint('❌ Conversation added stream error: $error');
          },
        );

    _messageDeleteSubscription = _messageHandler.messageDeleteStream.listen(
      _handleMessageDelete,
      onError: (error) {
        debugPrint('❌ Message delete stream error: $error');
      },
    );
  }

  /// Handle typing message
  void _handleTypingMessage(Map<String, dynamic> message) {
    try {
      final data = message['data'] as Map<String, dynamic>? ?? {};
      final conversationId = message['conversation_id'] as int?;
      final isTyping = data['is_typing'] as bool? ?? false;
      final userId = data['user_id'] as int?;
      final userName = data['user_name'] as String? ?? '';

      if (conversationId == null || userId == null) return;

      final groupIndex = state.groups.indexWhere(
        (group) => group.conversationId == conversationId,
      );

      if (groupIndex == -1) return;

      final group = state.groups[groupIndex];
      final typingUserName = userName.isNotEmpty
          ? userName
          : group.members
                .firstWhere(
                  (member) => member.userId == userId,
                  orElse: () => GroupMember(
                    userId: userId,
                    name: userName,
                    role: 'member',
                  ),
                )
                .name;

      if (isTyping) {
        final typingUsers = Map<int, bool>.from(state.typingUsers);
        final typingUserNames = Map<int, Set<String>>.from(
          state.typingUserNames,
        );

        typingUsers[conversationId] = true;
        typingUserNames.putIfAbsent(conversationId, () => <String>{});
        typingUserNames[conversationId]!.add(typingUserName);

        _typingTimers[conversationId]?.cancel();
        _typingTimers[conversationId] = Timer(const Duration(seconds: 2), () {
          final newTypingUsers = Map<int, bool>.from(state.typingUsers);
          final newTypingUserNames = Map<int, Set<String>>.from(
            state.typingUserNames,
          );
          newTypingUsers[conversationId] = false;
          newTypingUserNames.remove(conversationId);
          state = state.copyWith(
            typingUsers: newTypingUsers,
            typingUserNames: newTypingUserNames,
          );
          _typingTimers[conversationId] = null;
        });

        state = state.copyWith(
          typingUsers: typingUsers,
          typingUserNames: typingUserNames,
        );
      } else {
        final newTypingUsers = Map<int, bool>.from(state.typingUsers);
        final newTypingUserNames = Map<int, Set<String>>.from(
          state.typingUserNames,
        );

        newTypingUserNames[conversationId]?.remove(typingUserName);

        if (newTypingUserNames[conversationId]?.isEmpty ?? true) {
          newTypingUsers[conversationId] = false;
          newTypingUserNames.remove(conversationId);
          _typingTimers[conversationId]?.cancel();
          _typingTimers[conversationId] = null;
        }

        state = state.copyWith(
          typingUsers: newTypingUsers,
          typingUserNames: newTypingUserNames,
        );
      }
    } catch (e) {
      debugPrint('❌ Error handling typing message: $e');
    }
  }

  /// Handle new group message
  Future<void> _handleNewGroupMessage(Map<String, dynamic> message) async {
    try {
      final conversationId = message['conversation_id'] as int?;
      if (conversationId == null) return;

      final groupIndex = state.groups.indexWhere(
        (group) => group.conversationId == conversationId,
      );

      if (groupIndex == -1) return;

      final data = message['data'] as Map<String, dynamic>? ?? {};
      final group = state.groups[groupIndex];

      String messageBody = data['body'] ?? '';

      if (messageBody.isEmpty && data['data'] != null) {
        final nestedData = data['data'] as Map<String, dynamic>;
        messageBody =
            nestedData['message_type'] ?? nestedData['file_name'] ?? '';
      }

      final lastMessage = GroupLastMessage(
        id: data['id'] ?? data['media_message_id'] ?? 0,
        body: messageBody,
        type: messageBody.isEmpty
            ? 'attachment'
            : data['type'] ?? message['type'] ?? 'text',
        senderId: data['sender_id'] ?? data['user_id'] ?? 0,
        senderName: data['sender_name'] ?? '',
        createdAt: data['created_at'] ?? DateTime.now().toIso8601String(),
        conversationId: conversationId,
        attachmentData: data['attachments'],
      );

      await _lastMessageStorage.storeGroupLastMessage(conversationId, {
        'id': data['id'] ?? data['media_message_id'] ?? 0,
        'body': messageBody,
        'type': data['type'] ?? message['type'] ?? 'text',
        'sender_id': data['sender_id'] ?? data['user_id'] ?? 0,
        'sender_name': data['sender_name'] ?? '',
        'created_at': data['created_at'] ?? DateTime.now().toIso8601String(),
        'conversation_id': conversationId,
      });

      final updatedMetadata = GroupMetadata(
        lastMessage: lastMessage,
        totalMessages: (group.metadata?.totalMessages ?? 0) + 1,
        createdAt: group.metadata?.createdAt,
        createdBy: group.metadata?.createdBy ?? 0,
      );

      final newUnreadCount = state.activeConversationId == conversationId
          ? group.unreadCount
          : group.unreadCount + 1;

      final updatedGroup = GroupModel(
        conversationId: group.conversationId,
        title: group.title,
        type: group.type,
        members: group.members,
        metadata: updatedMetadata,
        unreadCount: newUnreadCount,
        lastMessageAt: lastMessage.createdAt,
        role: group.role,
        joinedAt: group.joinedAt,
      );

      final updatedGroups = List<GroupModel>.from(state.groups);
      updatedGroups[groupIndex] = updatedGroup;

      await _groupsRepo.insertOrUpdateGroup(updatedGroup);

      // Sort groups by last message time
      updatedGroups.sort((a, b) {
        final aTime = a.lastMessageAt ?? a.joinedAt;
        final bTime = b.lastMessageAt ?? b.joinedAt;
        return DateTime.parse(bTime).compareTo(DateTime.parse(aTime));
      });

      state = state.copyWith(groups: updatedGroups);
    } catch (e) {
      debugPrint('❌ Error handling new group message: $e');
    }
  }

  /// Handle conversation added
  Future<void> _handleConversationAdded(Map<String, dynamic> message) async {
    try {
      final conversationId = message['conversation_id'] as int?;
      final data = message['data'] as Map<String, dynamic>?;

      if (conversationId == null || data == null) return;

      final conversationType = data['type'] as String?;
      if (conversationType != 'group' &&
          conversationType != 'community_group') {
        return;
      }

      final existingIndex = state.groups.indexWhere(
        (group) => group.conversationId == conversationId,
      );

      if (existingIndex != -1) return;

      final group = _convertToGroupModel(data);
      final updatedGroups = await _updateGroupsWithStoredLastMessages([group]);

      if (updatedGroups.isNotEmpty) {
        final newGroups = [...state.groups, updatedGroups[0]];

        newGroups.sort((a, b) {
          final aTime = a.lastMessageAt ?? a.joinedAt;
          final bTime = b.lastMessageAt ?? b.joinedAt;
          return DateTime.parse(bTime).compareTo(DateTime.parse(aTime));
        });

        await _groupsRepo.insertOrUpdateGroup(updatedGroups[0]);

        state = state.copyWith(groups: newGroups);
      }
    } catch (e) {
      debugPrint('❌ Error handling conversation added: $e');
    }
  }

  /// Handle message delete
  Future<void> _handleMessageDelete(Map<String, dynamic> message) async {
    try {
      final conversationId = message['conversation_id'] as int?;
      final messageIds = message['message_ids'] as List<dynamic>? ?? [];

      if (conversationId == null || messageIds.isEmpty) return;

      final deletedMessageIds = messageIds.map((id) => id as int).toList();

      final groupIndex = state.groups.indexWhere(
        (group) => group.conversationId == conversationId,
      );

      if (groupIndex == -1) return;

      final group = state.groups[groupIndex];
      final lastMessage = group.metadata?.lastMessage;

      if (lastMessage != null && deletedMessageIds.contains(lastMessage.id)) {
        try {
          final historyResponse = await _chatsServices.getConversationHistory(
            conversationId: conversationId,
            page: 1,
            limit: 1,
          );

          if (historyResponse['success'] == true) {
            final messages =
                historyResponse['data']['messages'] as List<dynamic>? ?? [];

            final updatedGroups = List<GroupModel>.from(state.groups);

            if (messages.isNotEmpty) {
              final newLastMessageData = messages[0] as Map<String, dynamic>;
              final messageBody = newLastMessageData['body'] ?? '';

              final newLastMessage = GroupLastMessage(
                id: newLastMessageData['id'] ?? 0,
                body: messageBody,
                type: messageBody.isEmpty
                    ? 'attachment'
                    : newLastMessageData['type'] ?? 'text',
                senderId: newLastMessageData['sender_id'] ?? 0,
                senderName: newLastMessageData['sender_name'] ?? '',
                createdAt:
                    newLastMessageData['created_at'] ??
                    DateTime.now().toIso8601String(),
                conversationId: conversationId,
                attachmentData: newLastMessageData['attachments'],
              );

              final updatedMetadata = GroupMetadata(
                lastMessage: newLastMessage,
                totalMessages: group.metadata?.totalMessages ?? 0,
                createdAt: group.metadata?.createdAt,
                createdBy: group.metadata?.createdBy ?? 0,
              );

              final updatedGroup = GroupModel(
                conversationId: group.conversationId,
                title: group.title,
                type: group.type,
                members: group.members,
                metadata: updatedMetadata,
                unreadCount: group.unreadCount,
                lastMessageAt: newLastMessage.createdAt,
                role: group.role,
                joinedAt: group.joinedAt,
              );

              await _lastMessageStorage.storeGroupLastMessage(conversationId, {
                'id': newLastMessage.id,
                'body': newLastMessage.body,
                'type': newLastMessage.type,
                'sender_id': newLastMessage.senderId,
                'sender_name': newLastMessage.senderName,
                'created_at': newLastMessage.createdAt,
                'conversation_id': conversationId,
              });

              await _groupsRepo.insertOrUpdateGroup(updatedGroup);

              updatedGroups[groupIndex] = updatedGroup;
            } else {
              final updatedMetadata = GroupMetadata(
                lastMessage: null,
                totalMessages: group.metadata?.totalMessages ?? 0,
                createdAt: group.metadata?.createdAt,
                createdBy: group.metadata?.createdBy ?? 0,
              );

              final updatedGroup = GroupModel(
                conversationId: group.conversationId,
                title: group.title,
                type: group.type,
                members: group.members,
                metadata: updatedMetadata,
                unreadCount: group.unreadCount,
                lastMessageAt: null,
                role: group.role,
                joinedAt: group.joinedAt,
              );

              await _lastMessageStorage.storeGroupLastMessage(conversationId, {
                'id': 0,
                'body': '',
                'type': 'text',
                'sender_id': 0,
                'sender_name': '',
                'created_at': DateTime.now().toIso8601String(),
                'conversation_id': conversationId,
              });

              await _groupsRepo.insertOrUpdateGroup(updatedGroup);

              updatedGroups[groupIndex] = updatedGroup;
            }

            updatedGroups.sort((a, b) {
              final aTime = a.lastMessageAt ?? a.joinedAt;
              final bTime = b.lastMessageAt ?? b.joinedAt;
              return DateTime.parse(bTime).compareTo(DateTime.parse(aTime));
            });

            state = state.copyWith(groups: updatedGroups);
          }
        } catch (e) {
          debugPrint('❌ Error fetching new last message after delete: $e');
        }
      }
    } catch (e) {
      debugPrint('❌ Error handling message delete: $e');
    }
  }

  /// Dispose resources
  void dispose() {
    _typingSubscription?.cancel();
    _messageSubscription?.cancel();
    _mediaSubscription?.cancel();
    _conversationAddedSubscription?.cancel();
    _messageDeleteSubscription?.cancel();

    for (final timer in _typingTimers.values) {
      timer?.cancel();
    }
    _typingTimers.clear();
  }
}
