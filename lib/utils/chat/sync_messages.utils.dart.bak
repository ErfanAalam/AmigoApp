import 'package:flutter/material.dart';
import '../../api/chats.services.dart';

/// Configuration for loading initial messages
class LoadInitialMessagesConfig {
  final int conversationId;
  final MessagesRepository messagesRepo;
  final ChatsServices chatsServices;
  final bool Function() mounted;
  final void Function(VoidCallback) setState;

  // State getters
  final bool Function() hasCheckedCache;
  final List<MessageModel> Function() getMessages;
  final ConversationMeta? Function() getConversationMeta;
  final bool Function() getHasMoreMessages;
  final int Function() getCurrentPage;
  final bool Function() getIsInitialized;
  final bool Function() getIsLoading;
  final String? Function() getErrorMessage;
  final bool Function() getIsCheckingCache;
  final bool Function() getIsLoadingFromCache;

  // State setters
  final void Function(bool) setHasCheckedCache;
  final void Function(List<MessageModel>) setMessages;
  final void Function(ConversationMeta?) setConversationMeta;
  final void Function(bool) setHasMoreMessages;
  final void Function(int) setCurrentPage;
  final void Function(bool) setIsInitialized;
  final void Function(bool) setIsLoading;
  final void Function(String?) setErrorMessage;
  final void Function(bool) setIsCheckingCache;
  final void Function(bool) setIsLoadingFromCache;

  // Callbacks for specific operations
  final Future<void> Function(int conversationId) performSmartSync;
  final void Function(List<MessageModel> messages) validateMessages;
  final void Function() populateReplyMessageSenderNames;
  final Future<void> Function()?
  onAfterLoadFromServer; // Optional callback after server load (e.g., _cacheUsersFromMetadata)
  final void Function(List<MessageModel> messages)?
  onAfterLoadFromCache; // Optional callback after cache load (e.g., debugMessageDates)
  final List<MessageModel> Function(List<MessageModel> messages)?
  cleanCachedMessages; // Optional message cleaning (for groups)
  final void Function(Map<String, dynamic> response)?
  processMembersData; // Optional member data processing (for DM)
  final String Function()
  getErrorMessageText; // Error message text (different for DM vs group)
  final String Function() getNoCacheMessage; // No cache message text

  LoadInitialMessagesConfig({
    required this.conversationId,
    required this.messagesRepo,
    required this.chatsServices,
    required this.mounted,
    required this.setState,
    required this.hasCheckedCache,
    required this.getMessages,
    required this.getConversationMeta,
    required this.getHasMoreMessages,
    required this.getCurrentPage,
    required this.getIsInitialized,
    required this.getIsLoading,
    required this.getErrorMessage,
    required this.getIsCheckingCache,
    required this.getIsLoadingFromCache,
    required this.setHasCheckedCache,
    required this.setMessages,
    required this.setConversationMeta,
    required this.setHasMoreMessages,
    required this.setCurrentPage,
    required this.setIsInitialized,
    required this.setIsLoading,
    required this.setErrorMessage,
    required this.setIsCheckingCache,
    required this.setIsLoadingFromCache,
    required this.performSmartSync,
    required this.validateMessages,
    required this.populateReplyMessageSenderNames,
    this.onAfterLoadFromServer,
    this.onAfterLoadFromCache,
    this.cleanCachedMessages,
    this.processMembersData,
    required this.getErrorMessageText,
    required this.getNoCacheMessage,
  });
}

/// Shared function to load initial messages for both DM and group chats
Future<void> loadInitialMessages(LoadInitialMessagesConfig config) async {
  try {
    final conversationId = config.conversationId;

    // ALWAYS load from local DB first for instant display
    if (!config.hasCheckedCache()) {
      final cachedData = await config.messagesRepo.getCachedMessages(
        conversationId,
      );

      if (cachedData != null && cachedData.messages.isNotEmpty) {
        // Clean messages if cleaning function is provided (for groups)
        List<MessageModel> processedMessages = cachedData.messages;
        if (config.cleanCachedMessages != null) {
          processedMessages = config.cleanCachedMessages!(cachedData.messages);
        }

        if (config.mounted()) {
          config.setState(() {
            config.setIsCheckingCache(false);
            config.setIsLoadingFromCache(false);
            config.setMessages(processedMessages);
            config.setConversationMeta(cachedData.meta);
            config.setHasMoreMessages(cachedData.meta.hasNextPage);
            config.setCurrentPage(cachedData.meta.currentPage);
            config.setIsInitialized(true);
            config.setIsLoading(false);
            config.setErrorMessage(null);
            config.setHasCheckedCache(true);
          });

          // Optional callback after loading from cache (e.g., debugMessageDates for DM)
          if (config.onAfterLoadFromCache != null) {
            config.onAfterLoadFromCache!(processedMessages);
          }

          // Validate messages
          config.validateMessages(processedMessages);
          config.populateReplyMessageSenderNames();
        }
      } else {
        debugPrint(config.getNoCacheMessage());
        config.setHasCheckedCache(true);
      }
    }

    // If we already have messages from cache, do smart sync silently
    if (config.getMessages().isNotEmpty) {
      debugPrint('üì° Silently syncing with server in background...');
      await config.performSmartSync(conversationId);
      return;
    }

    // Show loading only if we don't have cached messages
    if (config.getMessages().isEmpty && config.mounted()) {
      config.setState(() {
        config.setIsCheckingCache(false);
        config.setIsLoading(true);
        config.setIsLoadingFromCache(false);
        config.setErrorMessage(null);
      });
    }

    try {
      final response = await config.chatsServices.getConversationHistory(
        conversationId: conversationId,
        page: 1,
        limit: 20,
      );

      if (!config.mounted()) return;

      if (response['success'] == true && response['data'] != null) {
        final historyResponse = ConversationHistoryResponse.fromJson(
          response['data'],
        );

        final processedMessages = historyResponse.messages;
        final conversationMeta = ConversationMeta.fromResponse(historyResponse);

        // Process members data if callback provided (for DM)
        if (config.processMembersData != null) {
          config.processMembersData!(response);
        }

        // Save to local DB
        await config.messagesRepo.saveMessages(
          conversationId: conversationId,
          messages: processedMessages,
          meta: conversationMeta,
        );

        config.setState(() {
          config.setMessages(processedMessages);
          config.setHasMoreMessages(historyResponse.hasNextPage);
          config.setCurrentPage(1);
          config.setIsLoading(false);
          config.setIsLoadingFromCache(false);
          config.setIsInitialized(true);
          config.setConversationMeta(conversationMeta);
        });

        // Optional callback after loading from cache (e.g., debugMessageDates for DM)
        if (config.onAfterLoadFromCache != null) {
          config.onAfterLoadFromCache!(processedMessages);
        }

        config.validateMessages(processedMessages);
        config.populateReplyMessageSenderNames();

        // Optional callback after server load (e.g., _cacheUsersFromMetadata for groups)
        if (config.onAfterLoadFromServer != null) {
          await config.onAfterLoadFromServer!();
        }
      } else {
        config.setState(() {
          config.setErrorMessage(
            response['message'] ?? config.getErrorMessageText(),
          );
          config.setIsLoading(false);
          config.setIsLoadingFromCache(false);
          config.setIsInitialized(true);
        });
      }
    } catch (e) {
      debugPrint('‚ùå Error loading messages from server: $e');

      // On network error, if we have cached data, keep showing it
      if (config.mounted()) {
        if (config.getMessages().isNotEmpty) {
          config.setState(() {
            config.setIsLoading(false);
            config.setIsLoadingFromCache(false);
            config.setIsInitialized(true);
            config.setErrorMessage(null); // Don't show error if we have cache
          });
        } else {
          config.setState(() {
            config.setErrorMessage('No internet connection');
            config.setIsLoading(false);
            config.setIsLoadingFromCache(false);
            config.setIsInitialized(true);
          });
        }
      }
    }
  } catch (e) {
    debugPrint('‚ùå Critical error in loadInitialMessages: $e');
    if (config.mounted()) {
      config.setState(() {
        config.setErrorMessage('Failed to load messages: ${e.toString()}');
        config.setIsLoading(false);
        config.setIsLoadingFromCache(false);
        config.setIsInitialized(true);
      });
    }
  }
}

/// Configuration for loading from cache first
class TryLoadFromCacheFirstConfig {
  final int conversationId;
  final MessagesRepository messagesRepo;
  final bool Function() mounted;
  final void Function(VoidCallback) setState;

  // State getters
  final bool Function() hasCheckedCache;

  // State setters
  final void Function(bool) setHasCheckedCache;
  final void Function(List<MessageModel>) setMessages;
  final void Function(ConversationMeta?) setConversationMeta;
  final void Function(bool) setHasMoreMessages;
  final void Function(int) setCurrentPage;
  final void Function(bool) setIsInitialized;
  final void Function(bool) setIsLoading;
  final void Function(String?) setErrorMessage;
  final void Function(bool) setIsCheckingCache;
  final void Function(bool) setIsLoadingFromCache;

  // Callbacks for specific operations
  final void Function(List<MessageModel> messages) validateMessages;
  final void Function() populateReplyMessageSenderNames;
  final List<MessageModel> Function(List<MessageModel> messages)?
  cleanCachedMessages; // Optional message cleaning (for groups)
  final void Function(List<MessageModel> messages, int originalCount)?
  onAfterLoadFromCache; // Optional callback after cache load (for debug prints)
  final String Function()
  getErrorLogMessage; // Error log message text (different for DM vs group)

  TryLoadFromCacheFirstConfig({
    required this.conversationId,
    required this.messagesRepo,
    required this.mounted,
    required this.setState,
    required this.hasCheckedCache,
    required this.setHasCheckedCache,
    required this.setMessages,
    required this.setConversationMeta,
    required this.setHasMoreMessages,
    required this.setCurrentPage,
    required this.setIsInitialized,
    required this.setIsLoading,
    required this.setErrorMessage,
    required this.setIsCheckingCache,
    required this.setIsLoadingFromCache,
    required this.validateMessages,
    required this.populateReplyMessageSenderNames,
    this.cleanCachedMessages,
    this.onAfterLoadFromCache,
    required this.getErrorLogMessage,
  });
}

/// Shared function to try loading from cache first for both DM and group chats
Future<void> tryLoadFromCacheFirst(TryLoadFromCacheFirstConfig config) async {
  if (config.hasCheckedCache()) return; // Avoid double-checking

  try {
    final conversationId = config.conversationId;

    final cachedData = await config.messagesRepo.getCachedMessages(
      conversationId,
    );

    if (cachedData != null &&
        cachedData.messages.isNotEmpty &&
        config.mounted()) {
      // Clean messages if cleaning function is provided (for groups)
      List<MessageModel> processedMessages = cachedData.messages;
      final originalCount = cachedData.messages.length;

      if (config.cleanCachedMessages != null) {
        processedMessages = config.cleanCachedMessages!(cachedData.messages);
      }

      config.setState(() {
        config.setIsCheckingCache(false);
        config.setIsLoadingFromCache(false);
        config.setMessages(processedMessages);
        config.setConversationMeta(cachedData.meta);
        config.setHasMoreMessages(cachedData.meta.hasNextPage);
        config.setCurrentPage(cachedData.meta.currentPage);
        config.setIsInitialized(true);
        config.setIsLoading(false);
        config.setErrorMessage(null);
        config.setHasCheckedCache(true);
      });

      // Validate messages
      config.validateMessages(processedMessages);
      config.populateReplyMessageSenderNames();

      // Optional callback after loading from cache (e.g., debug print for groups)
      if (config.onAfterLoadFromCache != null) {
        config.onAfterLoadFromCache!(processedMessages, originalCount);
      }
    } else {
      if (config.mounted()) {
        config.setState(() {
          config.setIsCheckingCache(false);
          config.setIsLoading(false); // Don't show loading yet
          config.setHasCheckedCache(true);
        });
      }
    }
  } catch (e) {
    debugPrint('‚ö° ${config.getErrorLogMessage()}: $e');
    if (config.mounted()) {
      config.setState(() {
        config.setIsCheckingCache(false);
        config.setIsLoading(false);
        config.setHasCheckedCache(true);
      });
    }
  }
}

/// Configuration for loading more messages (pagination)
class LoadMoreMessagesConfig {
  final int conversationId;
  final MessagesRepository messagesRepo;
  final ChatsServices chatsServices;
  final bool Function() mounted;
  final void Function(VoidCallback) setState;

  // State getters
  final bool Function() isLoadingMore;
  final bool Function() hasMoreMessages;
  final int Function() currentPage;
  final List<MessageModel> Function() getMessages;
  final ConversationMeta? Function() getConversationMeta;

  // State setters
  final void Function(bool) setIsLoadingMore;
  final void Function(bool) setHasMoreMessages;
  final void Function(int) setCurrentPage;
  final void Function(List<MessageModel>) setMessages;
  final void Function(ConversationMeta?) setConversationMeta;

  // Callbacks for specific operations
  final void Function() populateReplyMessageSenderNames;
  final void Function(Map<String, dynamic> response)?
  processMembersData; // Optional member data processing (for DM)
  final Future<void> Function()?
  onAfterLoadMore; // Optional callback after loading (e.g., _cacheUsersFromMetadata for groups)
  final void Function(String error)?
  onProcessingError; // Optional callback for processing errors (for DM SnackBar)
  final void Function(String error)?
  onLoadError; // Optional callback for load errors (for DM SnackBar)

  LoadMoreMessagesConfig({
    required this.conversationId,
    required this.messagesRepo,
    required this.chatsServices,
    required this.mounted,
    required this.setState,
    required this.isLoadingMore,
    required this.hasMoreMessages,
    required this.currentPage,
    required this.getMessages,
    required this.getConversationMeta,
    required this.setIsLoadingMore,
    required this.setHasMoreMessages,
    required this.setCurrentPage,
    required this.setMessages,
    required this.setConversationMeta,
    required this.populateReplyMessageSenderNames,
    this.processMembersData,
    this.onAfterLoadMore,
    this.onProcessingError,
    this.onLoadError,
  });
}

/// Shared function to load more messages (pagination) for both DM and group chats
Future<void> loadMoreMessages(LoadMoreMessagesConfig config) async {
  if (config.isLoadingMore() ||
      !config.hasMoreMessages() ||
      !config.mounted()) {
    return;
  }

  config.setState(() {
    config.setIsLoadingMore(true);
  });

  try {
    final response = await config.chatsServices.getConversationHistory(
      conversationId: config.conversationId,
      page: config.currentPage() + 1,
      limit: 20,
    );

    if (!config.mounted()) return;

    if (response['success'] == true && response['data'] != null) {
      try {
        final historyResponse = ConversationHistoryResponse.fromJson(
          response['data'],
        );

        // Process members data if callback provided (for DM)
        if (config.processMembersData != null) {
          config.processMembersData!(response);
        }

        // Update conversation metadata
        final conversationMeta = ConversationMeta.fromResponse(historyResponse);

        // Add to cache (insert at beginning for older messages)
        await config.messagesRepo.addMessagesToCache(
          conversationId: config.conversationId,
          newMessages: historyResponse.messages,
          updatedMeta: conversationMeta,
          insertAtBeginning: true,
        );

        config.setState(() {
          // Insert older messages at the beginning (chronologically)
          final currentMessages = List<MessageModel>.from(config.getMessages());
          currentMessages.insertAll(0, historyResponse.messages);
          config.setMessages(currentMessages);
          config.setHasMoreMessages(historyResponse.hasNextPage);
          config.setCurrentPage(config.currentPage() + 1);
          config.setIsLoadingMore(false);
          config.setConversationMeta(conversationMeta);
        });

        config.populateReplyMessageSenderNames();

        // Optional callback after loading (e.g., _cacheUsersFromMetadata for groups)
        if (config.onAfterLoadMore != null) {
          await config.onAfterLoadMore!();
        }
      } catch (processingError) {
        debugPrint(
          '‚ùå Error processing message history response: $processingError',
        );
        if (config.mounted()) {
          config.setState(() {
            config.setIsLoadingMore(false);
          });

          // Optional callback for processing errors (for DM SnackBar)
          if (config.onProcessingError != null) {
            config.onProcessingError!(processingError.toString());
          }
        }
      }
    } else {
      if (config.mounted()) {
        config.setState(() {
          config.setIsLoadingMore(false);
        });
      }
    }
  } catch (e) {
    debugPrint('‚ùå Error loading more messages: $e');
    if (config.mounted()) {
      config.setState(() {
        config.setIsLoadingMore(false);
      });

      // Optional callback for load errors (for DM SnackBar)
      if (config.onLoadError != null) {
        config.onLoadError!(e.toString());
      }
    }
  }
}
